# 개발계획서

### 0) 프로젝트 한 줄 소개

- 앱 이름(가칭): 이미지/문장 중심 아카이브
- 한 줄 요약: 내가 인터넷에서 웹사이트의 이미지/텍스트를 앱으로 공유하면 이미지/텍스트가 저장되는 앱
- 만들게 된 이유(개인 동기): 웹사이트의 단편적인 정보만을 아카이브하고 싶어서

---

### 1) 문제 & 목표 (개인 기준)

- 해결하고 싶은 문제(내가/주변이 겪는):
  - 기존 북마크 앱은 웹페이지의 모든 내용을 저장해서 한 눈에 필요한 것만 보기 어려움
  - 텍스트 파일 등으로 저장하자니 귀찮음
- 핵심 가치: 아카이빙하기에도, 보기에도 명료하게
- 완성의 기준(내가 만족하는 조건):
  - 내가 수시로 아카이빙을 하고 주 2회 이상 아카이브 복기를 하면 성공

---

### 2) 타겟 사용자(가정 가능)

- 주 사용자: 여러 웹사이트를 사용하는 사람
- 사용 시나리오(언제/어디서/왜): 수시로/어느 장소에서나/웹페이지 일부를 메모처럼 아카이브
- 사용자가 얻는 결과(변화): 쌓아두고 보지 않았던 정보의 핵심만을 다시 찾아볼 수 있음

---

### 3) 레퍼런스(중요) ✅

**3-1. 유사 앱/서비스 레퍼런스**

- 레퍼런스 A: Pocket(Mozila)
  - 참고 이유: 편리한 저장, tagging 시스템
  - 가져올 것(좋은 점): tagging, 공유를 통해 저장하는 매커니즘, 저장과 동시에 tagging 가능
  - 피할 것(불편한 점): UI(텍스트 중심의 ui), 웹페이지의 모든 걸 저장
- 레퍼런스 B: 핀터레스트
  - 참고 이유: 이미지 중심의 아카이빙/분류 앱
  - 가져올 것: 이미지 중심 UI, 보드 시스템
  - 피할 것: 이미지가 핀터레스트에 저장되어서 타인에게 공유되는 것
- 레퍼런스 C: mymind
  - 참고 이유: 이미지 중심의 아카이빙/분류 앱
  - 가져올 것
    - UI
  - 피할 것
    - 분류 방법-이미지 등록 후 태그를 달아야 함, 직관적이지 않은 폴더(?) 기능

**3-2. UI/UX 레퍼런스**

- 디자인 스타일 레퍼런스: 홈 그리드는 Pinterest, 저장 시 태깅은 Pocket
- 참고 화면(스크린샷/링크) 리스트:
- 내가 원하는 톤&무드 키워드 5개: 미니멀, 미래적, 정보밀도 낮게, 갤러리, 방해요소 없음

**3-3. 기능 레퍼런스**

- “이 기능은 여기처럼”:
  - 저장 UX: “저장은 Pocket처럼 **공유 → 저장 화면 → 태그/폴더 선택 → 저장**”
  - 홈 UI: “홈은 Pinterest처럼 **이미지 중심 Masonry 그리드**”
  - 폴더: “폴더는 Pinterest 보드처럼 **커버+이름+개수**로 표시”
  - 태그: “태그 입력은 Notion처럼 **자동완성 + 최근 태그 추천**”
  - 검색: “검색은 Spotlight처럼 **입력 즉시 결과 필터링**”
- “이건 절대 안 함/싫음”:
  - 강제 공개(공유/피드) 기능
  - 저장 후 태그 강제(저장하려면 태그 필수 같은 것)
  - 과도한 온보딩/튜토리얼
  - 너무 많은 메타데이터 자동 저장(웹페이지 전체 저장)
  - 광고/추천 피드(개인 프로젝트니까 더더욱)

---

### 4) 핵심 기능 정의 (MVP → 확장)

**4-1. MVP(최소 기능)**

- Must 기능 리스트(최대 5~7개 추천)
  - F1: 클라우드 지원
  - F2: 공유로 데이터(이미지, 짧은 텍스트) 업로드
  - F3: 업로드와 동시에 폴더, tag 선택 시스템
- 각 기능의 “완료 조건(Definition of Done)”
  - F1 완료 조건:
  - F2 완료 조건:

**4-2. 나중에 추가할 기능(Backlog)**

- Later 기능:
  - L1: 저장한 요소들을 동일 웹사이트 별로 묶어 보여주기
  - L2:

---

### 5) 사용자 흐름(User Flow)

- 시작 → 목표 달성까지 단계:
  1. 첫 실행: 로그인/게스트 선택 → 기본 폴더 1개 자동 생성
  2. 메인 진입: 홈 그리드(비어있으면 가이드 카드)
  3. 핵심 행동: 외부에서 공유 → 저장 화면에서 폴더/태그 선택 → 저장
  4. 결과 확인: 홈에 카드 생성 → 탭하면 상세에서 원문 열기/태그 수정
- 자주 일어나는 예외 케이스:
  - Empty(데이터 없음)
    - 문구: “아직 저장된 클립이 없어요. 웹에서 이미지/문장을 공유해보세요.”
    - 버튼: “저장 방법 보기” / “예시 클립 추가(선택)”
    - 가이드: “Safari/Chrome → 공유 → [앱 이름]”
  - 네트워크 오류
    - 배너: “동기화 실패. 오프라인으로 저장되고 연결되면 자동 업로드돼요.”
    - 버튼: “재시도”
  - 권한 거부(사진 접근 등)
    - 안내: “이미지 저장을 위해 사진 접근 권한이 필요해요.”
    - 버튼: “설정으로 이동” / “텍스트만 저장”

---

### 6) 화면 설계(스크린 목록)

- 화면 리스트(예: 5~10개):
  - S0: 온보딩/로그인(게스트 포함)
  - S1: 홈(전체 피드, 그리드)
  - S2: 저장(공유로 진입, 폴더/태그 선택)
  - S3: 폴더(보드) 목록/관리
  - S4: 클립 상세(복기/원문 열기/편집)
  - S5: 검색/필터(텍스트/태그/도메인)
  - S6: 설정(동기화/계정/기본값)

각 화면별로 아래 폼 반복:

- 폴더: 최근 3개 + 검색
- 태그: 최근 8개 칩 + 입력
- 장점: 저장 속도 최상
  - 목적(이 화면에서 유저가 해야 하는 것):
  - 구성요소(UI 컴포넌트):
  - 주요 액션(버튼/제스처):
  - 상태 설계:
    - Empty 상태:
    - Loading 상태:
    - Error 상태:
  - 참고 레퍼런스 화면: (링크/앱/스크린샷)

---

### 7) 데이터/저장 구조(간단 스키마)

### 7-1. 주요 엔티티(추천 확정)

### `users`

- `id (uuid, pk)`
- `created_at`

### `folders`

- `id (uuid, pk)`
- `user_id (fk users.id)`
- `name (text)`
- `created_at`
- (옵션) `cover_clip_id (uuid)`

### `tags`

- `id (uuid, pk)`
- `user_id`
- `name (text)` ← lowercase normalize 권장
- `created_at`
- (권장) unique(user_id, name)

### `clips` ✅ 핵심

- `id (uuid, pk)`
- `user_id`
- `folder_id (fk folders.id, nullable)` ← MVP에선 1개 폴더로 단순화
- `source_url (text, nullable)`
- `source_domain (text, nullable)`
- `text (text, nullable)` ← 선택 텍스트/짧은 메모용
- `note (text, nullable)` ← 사용자 추가 메모(선택)
- `thumb_path (text, nullable)` ← storage 경로
- `thumb_width (int, nullable)`
- `thumb_height (int, nullable)`
- `blurhash (text, nullable)` ← 선택
- `status (text)` ← `pending_upload | ready | pending_retry | failed`
- `last_error (text, nullable)`
- `created_at`, `updated_at`

### `clip_tags` (N:M)

- `clip_id (fk clips.id)`
- `tag_id (fk tags.id)`
- pk(clip_id, tag_id)

---

### 7-2. 로컬 저장/동기화 구조(오프라인/재시도)

### 로컬 DB(예: SQLite)

- `local_clips` (또는 clips를 로컬에도 동일 스키마로)
- `sync_queue` ✅ 권장
  - `id (uuid)`
  - `op (text)` : `create_clip | upload_thumb | update_clip | delete_clip`
  - `clip_id`
  - `payload_json (text)`
  - `retry_count (int)`
  - `last_error (text)`
  - `next_retry_at (timestamp)`
  - `created_at`

**규칙**

- 공유 진입 → 로컬에 먼저 저장 + 썸네일 임시파일 저장 → `sync_queue`에 enqueue
- 온라인이면 즉시 실행, 실패하면 백오프 재시도
- 성공하면 `status=ready`로 업데이트

---

### 7-3. Storage 버킷/경로 규칙(추천)

- bucket: `thumbs`
- path:
  - `userId/clipId/thumb.jpg`
  - (WebP면) `userId/clipId/thumb.webp`

### 7-4. 접근 권한(“타인 공유 금지” 요구 반영)

- 기본: **Private bucket** (유저 본인만 접근)
- 앱에서 이미지 보여줄 때:
  - (Supabase 기준) **signed URL 발급** 또는 **권한 있는 클라이언트 SDK로 fetch**
- 캐시 전략:
  - signed URL 만료는 적당히(예: 1시간~24시간)
  - 클라이언트 캐시(메모리/디스크)로 스크롤 성능 확보

---

### MVP 정책(단순)

- URL만 들어오면:
  - `thumb_path` 없이 저장(텍스트/도메인 카드)
  - `status=ready` (이미지가 없는 ready)

### 개선 정책(추천: FastAPI 메타 추출)

- URL 입력 → 서버가 OG 이미지/제목 가져와 썸네일 생성 후 `clips.thumb_*` 갱신

---

---

### 8) 비기능 요구사항

- 성능 목표(대충):
  - (예: 앱 켜지고 2초 안에 첫 화면)
- 개인정보/보안:
  - 어떤 데이터 저장? 어디에? 기간?
- 오프라인 지원 여부:
  - (예: 지하철에서도 기본 기능은 되게)

---

### 10) 개발 스택 & 규칙(본인용)

### 추천 스택(개인 프로젝트 밸런스)

- 앱(모바일): iOS/Android 중 선택(또는 크로스플랫폼)
- 백엔드/DB: **Supabase(Postgres + Auth + Storage)**
- Typescript + Expo(React native)
- 파이썬(FastAPI): **URL 메타 추출/썸네일링이 필요할 때만** 붙이기
- 로컬 DB: SQLite(오프라인 큐/캐시)

### 작업 규칙(초기 추천)

- 폴더 구조 원칙:
  - `screens/`, `components/`, `services/ (api, storage, sync)`, `db/`, `models/`
- 커밋 규칙:
  - `feat:`, `fix:`, `refactor:`, `chore:`
